/*
BSD 2-Clause License

Copyright (c) 2019, Beigesoftâ„¢
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.beigesoft.rdb;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;

import org.beigesoft.exc.ExcCode;
import org.beigesoft.mdl.IRecSet;
import org.beigesoft.mdl.ColVals;
import org.beigesoft.mdl.IHasId;
import org.beigesoft.fct.IFcClFcRq;
import org.beigesoft.fct.IFctRq;
import org.beigesoft.log.ILog;
import org.beigesoft.cnv.IFilEntRs;
import org.beigesoft.cnv.IFilCvEnt;
import org.beigesoft.prp.ISetng;

/**
 * <p>ORM service.
 * For insert and update use sorted array of fields names pVs["ndFds"]
 * to restrict affected fields.
 * For select use sorted array of fields names pVs["[entitySimpleName]ndFds"]
 * to retrieve only needed fields.
 * </p>
 *
 * @param <RS> platform dependent record set type
 * @author Yury Demidenko
 */
public class Orm<RS> implements IOrm {

  //Configuration:
  /**
   * <p>Android configuration, RDB insert returns autogenerated ID.</p>
   **/
  private boolean isAndr = false;

  /**
   * <p>New database ID.</p>
   **/
  private int newDbId = 1;

  //Services:
  /**
   * <p>Log.</p>
   **/
  private ILog log;

  /**
   * <p>Settings service.</p>
   **/
  private ISetng setng;

  /**
   * <p>RDBMS service.</p>
   **/
  private IRdb<RS> rdb;

  /**
   * <p>Generating select service.</p>
   **/
  private ISqlQu sqlQu;

  /**
   * <p>Filler entity from RS.</p>
   **/
  private IFilEntRs<RS> filEntRs;

  /**
   * <p>Factory of entity's factory.</p>
   **/
  private IFcClFcRq fctFctEnt;

  /**
   * <p>Generating insert/update and CV service.</p>
   **/
  private SrvClVl srvClVl;

  /**
   * <p>Fills CV from entity service.</p>
   **/
  private IFilCvEnt filCvEn;

  /**
   * <p>Initializes database, e.g. create/updates tables if need.
   * It must be invoked once by an initializer (e.g. load on startup servlet).
   * </p>
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @throws Exception - an exception
   **/
  @Override
  public final void init(final Map<String, Object> pRvs) throws Exception {
    //checking exist, creating:
    String checkTbl = this.setng.lazCmnst().get(CHECKTBL);
    boolean allCr = true;
    boolean anyCr = false;
    for (Class<? extends IHasId<?>> cls : this.setng.lazClss()) {
      String sel = checkTbl.replace(TBLNM, cls.getSimpleName().toUpperCase());
      boolean tbExs = false;
      IRecSet<RS> rs = null;
      try {
        rs = this.rdb.retRs(sel);
        tbExs = rs.first();
      } finally {
        if (rs != null) {
          rs.close();
        }
      }
      if (!tbExs) {
        //different standards:
        sel = checkTbl.replace(TBLNM, cls.getSimpleName().toLowerCase());
        rs = null;
        try {
          rs = this.rdb.retRs(sel);
          tbExs = rs.first();
        } finally {
          if (rs != null) {
            rs.close();
          }
        }
        if (!tbExs) {
          anyCr = true;
          String cre = this.sqlQu.evCreate(pRvs, cls);
          this.log.info(pRvs, getClass(), "Try to execute " + cre);
          try {
            this.rdb.exec(cre);
          } catch (Exception e) {
            throw e;
          } finally {
            this.rdb.release();
          }
        }
      }
      if (tbExs) {
        allCr = false;
      }
    }
    String setPth = "/" + this.setng.getDir() + "/";
    this.rdb.release(); //new connection required
    if (!allCr && anyCr) {
      //upgrading:
      Integer nxVr = this.rdb.getDbInf().getDbVr() + 1;
      String pth = setPth + UPGRSQL + nxVr + ".sql";
      String upgAll = loadStr(pth);
      while (upgAll != null) {
        this.log.info(pRvs, getClass(), "Found " + pth);
        for (String upg : upgAll.split("\n")) {
          if (upg.trim().length() > 1 && !upg.startsWith("/")) {
            this.log.info(pRvs, getClass(), "Try to execute " + upg);
            try {
              this.rdb.exec(upg);
            } catch (Exception e) {
              this.log.error(pRvs, getClass(), "Can't execute upgrade ", e);
            }
          }
        }
        nxVr++;
        pth = setPth + UPGRSQL + nxVr + ".sql";
        upgAll = loadStr(pth);
        this.rdb.release();
      }
    }
    //initialization script:
    String pth = setPth + INITSQL;
    String init = loadStr(pth);
    if (init != null) {
      this.log.info(pRvs, getClass(), "Found " + pth);
      for (String ini : init.split("\n")) {
        if (ini.trim().length() > 1 && !ini.startsWith("/")) {
          this.log.info(pRvs, getClass(), "Try to execute " + ini);
          try {
            this.rdb.exec(ini);
          } catch (Exception e) {
            this.log.error(pRvs, getClass(), "Can't execute init ", e);
          }
        }
      }
      this.rdb.release();
    }
    if (allCr) {
      this.log.info(pRvs, getClass(), "All tables has been created");
      pth = setPth + INSTSQL;
      String inst = loadStr(pth);
      if (inst != null) {
        this.log.info(pRvs, getClass(), "Found " + pth);
        for (String ins : inst.split("\n")) {
          if (ins.trim().length() > 1 && !ins.startsWith("/")) {
            this.log.info(pRvs, getClass(), "Try to execute " + ins);
            try {
              this.rdb.exec(ins);
            } catch (Exception e) {
              this.log.error(pRvs, getClass(), "Can't execute insert ", e);
            }
          }
        }
        this.rdb.release();
      }
      String appInf = this.setng.lazCmnst().get(APPINF);
      if (appInf == null) {
        throw new ExcCode(ExcCode.WRCN, "There is no common setting appInf!");
      }
      String insdbi = "insert into DBINF (DBVR, VER, DBID, INF) values (1, 1, "
        + this.newDbId + ", '" + appInf + "');";
      try {
        this.rdb.exec(insdbi);
      } catch (Exception e) {
        this.log.error(pRvs, getClass(), "Can't init DBINF ", e);
        throw e;
      } finally {
        this.rdb.release();
      }
    } else if (anyCr) {
      this.log.info(pRvs, getClass(), "Part of tables has been created");
    } else {
      this.log.info(pRvs, getClass(), "Tables already created");
    }
  }

  /**
   * <p>Retrieves entity from DB.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pEnt entity
   * @return entity or null
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> T retEnt(final Map<String, Object> pRvs,
    final Map<String, Object> pVs, final T pEnt) throws Exception {
    StringBuffer sb = this.sqlQu.evSel(pRvs, pVs, pEnt.getClass());
    sb.append(" where ");
    this.sqlQu.evCndId(pRvs, pEnt, sb);
    sb.append(";");
    @SuppressWarnings("unchecked")
    T ent = (T) retEntQu(pRvs, pVs, pEnt.getClass(), sb.toString());
    return ent;
  }

  /**
   * <p>Retrieves entity from DB by query conditions, if more than 1 result,
   * then trows exception.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @param pCond Not NULL e.g. "ORID=1 and DBID=2"
   * @return entity or null
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> T retEntCnd(final Map<String, Object> pRvs,
    final Map<String, Object> pVs, final Class<T> pCls,
      final String pCond) throws Exception {
    StringBuffer sb = this.sqlQu.evSel(pRvs, pVs, pCls);
    sb.append(" where " + pCond + ";");
    return retEntQu(pRvs, pVs, pCls, sb.toString());
  }

  /**
   * <p>Refreshes entity from DB. If not found then ID will be nulled.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pEnt entity
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> void refrEnt(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final T pEnt) throws Exception {
    StringBuffer sb = this.sqlQu.evSel(pRvs, pVs, pEnt.getClass());
    sb.append(" where ");
    this.sqlQu.evCndId(pRvs, pEnt, sb);
    sb.append(";");
    IRecSet<RS> rs = null;
    try {
      rs = this.rdb.retRs(sb.toString());
      if (rs.first()) {
        this.filEntRs.fill(pRvs, pVs, pEnt, rs);
        if (rs.next()) {
          throw new ExcCode(ExcCode.WRPR,
            "Select entity returns more than 1 result - " + sb.toString());
        }
      } else {
        pEnt.setIid(null);
      }
    } finally {
      if (rs != null) {
        rs.close();
      }
    }
  }

  /**
   * <p>Retrieves entity from DB by query, if more than 1 result,
   * then trows exception.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @param pQu SELECT statement
   * @return entity or null
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> T retEntQu(final Map<String, Object> pRvs,
    final Map<String, Object> pVs, final Class<T> pCls,
      final String pQu) throws Exception {
    T ent = null;
    IRecSet<RS> rs = null;
    try {
      rs = this.rdb.retRs(pQu);
      if (rs.first()) {
        IFctRq<T> fctEnt = this.fctFctEnt.laz(pRvs, pCls);
        ent = fctEnt.create(pRvs);
        this.filEntRs.fill(pRvs, pVs, ent, rs);
        if (rs.next()) {
          throw new ExcCode(ExcCode.WRPR,
            "Select entity returns more than 1 result - " + pQu);
        }
      }
    } finally {
      if (rs != null) {
        rs.close();
      }
    }
    return ent;
  }

  /**
   * <p>Inserts entity into DB. It's should be used by generic requester that
   * is not dedicated to concrete entity type, e.g. HTML request handler.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pEnt entity
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> void insert(final Map<String, Object> pRvs,
    final Map<String, Object> pVs, final T pEnt) throws Exception {
    if (pEnt.getIid() == null) {
      insIdLn(pRvs, pVs, (IHasId<Long>) pEnt);
    } else {
      insIdNln(pRvs, pVs, pEnt);
    }
  }

  /**
   * <p>Inserts entity with No Long ID into DB.
   * It's should be used by requester that is dedicated to concrete entity
   * type with no Long ID, e.g. account saver and account has string ID.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pEnt entity
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> void insIdNln(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final T pEnt) throws Exception {
    ColVals cv = new ColVals();
    this.filCvEn.fill(pRvs, pVs, pEnt, cv);
    long r = this.rdb.insert(pEnt.getClass(), cv);
    if (!this.isAndr && r != 1) {
      String qu = getSrvClVl().evInsert(pEnt.getClass(), cv);
throw new ExcCode(ACTROWERR, "It should be 1 row inserted but it is " + r
+ ", query:\n" + qu + ";\n" + "CV - "  + getSrvClVl().str(pEnt.getClass(), cv));
    }
    pEnt.setIsNew(Boolean.FALSE);
  }

  /**
   * <p>Inserts entity with Long ID (maybe auto-generated) into DB.
   * It's should be used by requester that is dedicated to concrete entity
   * type with Long ID, e.g. invoice saver.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pEnt entity
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<Long>> void insIdLn(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final T pEnt) throws Exception {
    ColVals cv = new ColVals();
    this.filCvEn.fill(pRvs, pVs, pEnt, cv);
    long r; //may has autogenerated ID
    if (this.isAndr || pEnt.getIid() != null) {
      r = this.rdb.insert(pEnt.getClass(), cv);
    } else { //autogenerated non-Android:
      String lastId = this.setng.lazCmnst().get(LASTID);
      String retId = this.setng.lazCmnst().get(RETID);
      if (lastId == null && retId == null) {
       throw new ExcCode(ExcCode.WRCN, "Must be setting lastId or retId!");
      }
      if (lastId != null && retId != null) {
       throw new ExcCode(ExcCode.WRCN, "Must be only setting lastId or retId!");
      }
      if (lastId != null) { //SQlite, MySql like
        r = this.rdb.insert(pEnt.getClass(), cv);
        if (r == 1L) {
          Long li = this.rdb.evLong(lastId, "LASTID");
          if (li == null) {
           throw new ExcCode(ExcCode.WRCN, "Wrong lastId - " + lastId);
          }
          r = li;
        }
      } else { //Postgresql like
        List<String> idNms = this.setng.lazIdFldNms(pEnt.getClass());
        retId = retId.replace(":RETID", idNms.get(0).toUpperCase());
        String qu = getSrvClVl().evInsert(pEnt.getClass(), cv);
        qu = qu.substring(0, qu.length() - 1) + " " + retId;
        Long li = this.rdb.evLong(qu, idNms.get(0).toUpperCase());
        if (li == null) {
         throw new ExcCode(ExcCode.WRCN, "Wrong retId - " + qu);
        }
        r = li;
      }
    }
    if (pEnt.getIid() == null && r > 0L) {
      pEnt.setIid(r);
    } else if (!this.isAndr && r == -1L || r != 1L) {
      String qu = getSrvClVl().evInsert(pEnt.getClass(), cv);
throw new ExcCode(ACTROWERR, "It should be 1 row inserted but it is " + r
+ ", query:\n" + qu + ";\n" + "CV - "  + getSrvClVl().str(pEnt.getClass(), cv));
    }
    pEnt.setIsNew(Boolean.FALSE);
  }

  /**
   * <p>Updates entity with ID in DB.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pEnt entity
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> void update(final Map<String, Object> pRvs,
    final Map<String, Object> pVs, final T pEnt) throws Exception {
    ColVals cv = new ColVals();
    this.filCvEn.fill(pRvs, pVs, pEnt, cv);
    String whe = this.srvClVl.evWheUpd(pEnt.getClass(), cv);
    int r = this.rdb.update(pEnt.getClass(), cv, whe);
    if (r != 1) {
      if (r == 0) {
        throw new ExcCode(DRTREAD, "dirty_read");
      } else {
      String qu = getSrvClVl().evUpdate(pEnt.getClass(), cv);
throw new ExcCode(ACTROWERR, "It should be 1 row updated but it is " + r
+ ", query:\n" + qu + ";\n" + "CV - "  + getSrvClVl().str(pEnt.getClass(), cv));
      }
    }
  }

  /**
   * <p>Deletes entity with ID from DB.</p>
   * @param <T> entity type
   * @param pRvs request scoped vars
   * @param pVs invoker scoped vars
   * @param pEnt entity
   * @throws Exception - an exception
   **/
  @Override
  public final <T extends IHasId<?>> void del(final Map<String, Object> pRvs,
    final Map<String, Object> pVs, final T pEnt) throws Exception {
    ColVals cv = new ColVals();
    this.filCvEn.fill(pRvs, pVs, pEnt, cv);
    String whe = this.srvClVl.evWheUpd(pEnt.getClass(), cv); //with OL
    int r = this.rdb.delete(pEnt.getClass().getSimpleName().toUpperCase(), whe);
    if (r != 1) {
      if (r == 0) {
        throw new ExcCode(DRTREAD, "dirty_read");
      } else {
        throw new ExcCode(ACTROWERR, "It should be 1 row deleted but it is "
          + r + ", where: " + whe + ", class: " + pEnt.getClass());
      }
    }
  }

  /**
   * <p>Retrieves a list of all entities.</p>
   * @param <T> - type of business object,
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @return list of all business objects or empty list, not null
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> List<T> retLst(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls) throws Exception {
    StringBuffer sb = this.sqlQu.evSel(pRvs, pVs, pCls);
    sb.append(";");
    return retLstQu(pRvs, pVs, pCls, sb.toString());
  }

  /**
   * <p>Retrieves a list of entities.</p>
   * @param <T> - type of business object
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @param pCond Not NULL e.g. "where name='U1' ORDER BY id"
   * @return list of business objects or empty list, not null
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> List<T> retLstCnd(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls, final String pCond) throws Exception {
    StringBuffer sb = this.sqlQu.evSel(pRvs, pVs, pCls);
    sb.append(" " + pCond + ";");
    return retLstQu(pRvs, pVs, pCls, sb.toString());
  }

  /**
   * <p>Retrieves a list of entities by complex query that may contain
   * additional joins and filters, see Beige-Webstore for example.</p>
   * @param <T> - type of business object
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @param pQu Not NULL complex query
   * @return list of business objects or empty list, not null
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> List<T> retLstQu(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls, final String pQu) throws Exception {
    List<T> ents = new ArrayList<T>();
    IRecSet<RS> rs = null;
    try {
      rs = this.rdb.retRs(pQu);
      if (rs.first()) {
        IFctRq<T> fctEnt = this.fctFctEnt.laz(pRvs, pCls);
        do {
          T ent = fctEnt.create(pRvs);
          this.filEntRs.fill(pRvs, pVs, ent, rs);
          ents.add(ent);
        } while (rs.next());
      }
    } finally {
      if (rs != null) {
        rs.close();
      }
    }
    return ents;
  }

  /**
   * <p>Retrieves a page of entities.</p>
   * @param <T> - type of business object,
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @param pFst number of the first record (from 0)
   * @param pPgSz page size (max records)
   * @return list of business objects or empty list, not null
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> List<T> retPg(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls, final Integer pFst,
        final Integer pPgSz) throws Exception {
    StringBuffer sb = this.sqlQu.evSel(pRvs, pVs, pCls);
    return retPgQu(pRvs, pVs, pCls, sb.toString(), pFst, pPgSz);
  }

  /**
   * <p>Retrieves a page of entities.</p>
   * @param <T> - type of business object,
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @param pCond not null e.g. "where name='U1' ORDER BY id"
   * @param pFst number of the first record (from 0)
   * @param pPgSz page size (max records)
   * @return list of business objects or empty list, not null
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> List<T> retPgCnd(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls, final String pCond, final Integer pFst,
        final Integer pPgSz) throws Exception {
    StringBuffer sb = this.sqlQu.evSel(pRvs, pVs, pCls);
    sb.append(" " + pCond);
    return retPgQu(pRvs, pVs, pCls, sb.toString(), pFst, pPgSz);
  }

  /**
   * <p>Retrieves a page of entities by given complex query.
   * For example it used to retrieve page Itms to sell in Beige-Webstore
   * by complex query what might consist of joints to filtered goods/services,
   * it also may has not all fields e.g. omit unused auctioning fields for
   * performance advantage.</p>
   * @param <T> - type of business object,
   * @param pRvs request scoped vars, e.g. user preference decimal separator
   * @param pVs invoker scoped vars, e.g. "needed fields", not null
   * @param pCls entity class
   * @param pQu not null complex query without page conditions
   * @param pFst number of the first record (from 0)
   * @param pPgSz page size (max records)
   * @return list of business objects or empty list, not null
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> List<T> retPgQu(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls, final String pQu, final Integer pFst,
        final Integer pPgSz) throws Exception {
    List<T> ents = new ArrayList<T>();
    IRecSet<RS> rs = null;
    try {
      rs = this.rdb.retRs(pQu + " limit " + pPgSz + " offset " + pFst + ";");
      if (rs.first()) {
        IFctRq<T> fctEnt = this.fctFctEnt.laz(pRvs, pCls);
        do {
          T ent = fctEnt.create(pRvs);
          this.filEntRs.fill(pRvs, pVs, ent, rs);
          ents.add(ent);
        } while (rs.next());
      }
    } finally {
      if (rs != null) {
        rs.close();
      }
    }
    return ents;
  }

  /**
   * <p>Calculates total rows for given entity class.</p>
   * @param <T> - type of business object,
   * @param pRvs request scoped vars
   * @param pVs invoker scoped vars, nullable
   * @param pCls entity class
   * @return Integer row count
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> Integer evRowCnt(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls) throws Exception {
    String qu = "select count(*) as TROWS from " + pCls.getSimpleName()
      .toUpperCase() + ";";
    return this.rdb.evInt(qu, "TROWS");
  }

  /**
   * <p>Calculates total rows for given entity class and conditions.</p>
   * @param <T> - type of business object,
   * @param pRvs request scoped vars
   * @param pVs invoker scoped vars
   * @param pCls entity class
   * @param pWhe not null e.g. "ITSID > 33"
   * @return Integer row count
   * @throws Exception - an exception
   */
  @Override
  public final <T extends IHasId<?>> Integer evRowCntWhe(
    final Map<String, Object> pRvs, final Map<String, Object> pVs,
      final Class<T> pCls, final String pWhe) throws Exception {
    String qu = "select count(*) as TROWS from " + pCls.getSimpleName()
      .toUpperCase() + " where " + pWhe + ";";
    return this.rdb.evInt(qu, "TROWS");
  }

  /**
   * <p>Getter for database ID.
   * Any database mist has ID, int is suitable type for that cause
   * its range is enough and it's faster than String.</p>
   * @return ID database
   * @throws Exception - an exception
   **/
  @Override
  public final Integer getDbId() throws Exception {
    return this.rdb.getDbInf().getDbId();
  }

  //Utils:
  /**
   * <p>Load string file (usually SQL query).</p>
   * @param pFiNm file name
   * @return String usually SQL query
   * @throws IOException - IO exception
   **/
  public final String loadStr(final String pFiNm) throws IOException {
    URL urlFile = Orm.class.getResource(pFiNm);
    if (urlFile != null) {
      InputStream is = null;
      try {
        is = Orm.class.getResourceAsStream(pFiNm);
        byte[] bArr = new byte[is.available()];
        is.read(bArr, 0, is.available());
        return new String(bArr, "UTF-8");
      } finally {
        if (is != null) {
          is.close();
        }
      }
    }
    return null;
  }

  //Simple getters and setters:
  /**
   * <p>Getter for isAndr.</p>
   * @return boolean
   **/
  public final boolean getIsAndr() {
    return this.isAndr;
  }

  /**
   * <p>Setter for isAndr.</p>
   * @param pIsAndr reference
   **/
  public final void setIsAndr(final boolean pIsAndr) {
    this.isAndr = pIsAndr;
  }

  /**
   * <p>Getter for newDbId.</p>
   * @return int
   **/
  public final int getNewDbId() {
    return this.newDbId;
  }

  /**
   * <p>Setter for newDbId.</p>
   * @param pNewDbId reference
   **/
  public final void setNewDbId(final int pNewDbId) {
    this.newDbId = pNewDbId;
  }

  /**
   * <p>Getter for log.</p>
   * @return ILog
   **/
  public final ILog getLog() {
    return this.log;
  }

  /**
   * <p>Setter for log.</p>
   * @param pLog reference
   **/
  public final void setLog(final ILog pLog) {
    this.log = pLog;
  }

  /**
   * <p>Getter for setng.</p>
   * @return ISetng
   **/
  public final ISetng getSetng() {
    return this.setng;
  }

  /**
   * <p>Setter for setng.</p>
   * @param pSetng reference
   **/
  public final void setSetng(final ISetng pSetng) {
    this.setng = pSetng;
  }

  /**
   * <p>Getter for rdb.</p>
   * @return IRdb<RS>
   **/
  public final IRdb<RS> getRdb() {
    return this.rdb;
  }

  /**
   * <p>Setter for rdb.</p>
   * @param pRdb reference
   **/
  public final void setRdb(final IRdb<RS> pRdb) {
    this.rdb = pRdb;
  }

  /**
   * <p>Getter for sqlQu.</p>
   * @return ISqlQu
   **/
  public final ISqlQu getSqlQu() {
    return this.sqlQu;
  }

  /**
   * <p>Setter for sqlQu.</p>
   * @param pSqlQu reference
   **/
  public final void setSqlQu(final ISqlQu pSqlQu) {
    this.sqlQu = pSqlQu;
  }

  /**
   * <p>Getter for filEntRs.</p>
   * @return IFilEntRs<RS>
   **/
  public final IFilEntRs<RS> getFilEntRs() {
    return this.filEntRs;
  }

  /**
   * <p>Setter for filEntRs.</p>
   * @param pFilEntRs reference
   **/
  public final void setFilEntRs(final IFilEntRs<RS> pFilEntRs) {
    this.filEntRs = pFilEntRs;
  }

  /**
   * <p>Getter for fctFctEnt.</p>
   * @return IFcClFcRq
   **/
  public final IFcClFcRq getFctFctEnt() {
    return this.fctFctEnt;
  }

  /**
   * <p>Setter for fctFctEnt.</p>
   * @param pFctFctEnt reference
   **/
  public final void setFctFctEnt(final IFcClFcRq pFctFctEnt) {
    this.fctFctEnt = pFctFctEnt;
  }

  /**
   * <p>Getter for srvClVl.</p>
   * @return SrvClVl
   **/
  public final SrvClVl getSrvClVl() {
    return this.srvClVl;
  }

  /**
   * <p>Setter for srvClVl.</p>
   * @param pSrvClVl reference
   **/
  public final void setSrvClVl(final SrvClVl pSrvClVl) {
    this.srvClVl = pSrvClVl;
  }

  /**
   * <p>Getter for filCvEn.</p>
   * @return IFilCvEnt
   **/
  public final IFilCvEnt getFilCvEn() {
    return this.filCvEn;
  }

  /**
   * <p>Setter for filCvEn.</p>
   * @param pFilCvEn reference
   **/
  public final void setFilCvEn(final IFilCvEnt pFilCvEn) {
    this.filCvEn = pFilCvEn;
  }
}
